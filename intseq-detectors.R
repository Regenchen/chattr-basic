compose_edges <- function(tttbl) {
  tttbl <- tttbl %>%
    mutate(
      anchor.L.start.ms = NA,
      anchor.L.stop.ms = NA,
      anchor.L.speaker = NA,
      anchor.R.start.ms = NA,
      anchor.R.stop.ms = NA,
      anchor.R.speaker = NA
    )
  for (i in 1:nrow(tttbl)) {
    # find the earliest increment
    prompt.start <- tttbl$prompt.start.ms[i]
    # if there's a prompt...
    if (!is.na(prompt.start)) {
      tttbl$anchor.L.speaker[i] <- tttbl$prompt.spkr[i]
      prompt.prev.start <- tttbl$prompt.prev.increment.start[i]
      # look for a pre-prompt utterance
      # if it's there, take that as the earliest
      if(!is.na(prompt.prev.start)) {
        tttbl$anchor.L.start.ms[i] <- prompt.prev.start
        tttbl$anchor.L.stop.ms[i] <- tttbl$prompt.prev.increment.stop[i]
      } else { # if not, set the prompt start as the earliest
        tttbl$anchor.L.start.ms[i] <- prompt.start
        tttbl$anchor.L.stop.ms[i] <- tttbl$prompt.stop.ms[i]
      }
    } else { # if there's no prompt, set the focus spkr
      # start as the earliest
      tttbl$anchor.L.speaker[i] <- tttbl$speaker[i]
      tttbl$anchor.L.start.ms[i] <- tttbl$start.ms[i]
      tttbl$anchor.L.stop.ms[i] <- tttbl$stop.ms[i]
    }
    # find the latest increment
    response.stop <- tttbl$response.stop.ms[i]
    # if there's a response...
    if (!is.na(response.stop)) {
      tttbl$anchor.R.speaker[i] <- tttbl$response.spkr[i]
      response.post.stop <- tttbl$response.post.increment.stop[i]
      # look for a post-response utterance
      # if it's there, take that as the latest
      if (!is.na(response.post.stop)) {
        tttbl$anchor.R.start.ms[i] <- tttbl$response.post.increment.start[i]
        tttbl$anchor.R.stop.ms[i] <- response.post.stop
      } else { # if not, set the response stop as the latest
        tttbl$anchor.R.start.ms[i] <- tttbl$response.start.ms[i]
        tttbl$anchor.R.stop.ms[i] <- response.stop
      }
    } else { # if there's no response, set the focus spkr
      # stop as the latest
      tttbl$anchor.R.speaker[i] <- tttbl$speaker[i]
      tttbl$anchor.R.start.ms[i] <- tttbl$start.ms[i]
      tttbl$anchor.R.stop.ms[i] <- tttbl$stop.ms[i]
    }
  }
  return(tttbl)
}

# Finds continuous sequences of interaction featuring the focus child
# and their contingently prompting/responding interactants
# uses the turn transition table format generated by fetch_transitions()
fetch_intseqs <- function(tttbl) {
  seq.stats <- tibble(
    speaker = character(),
    seq.num = integer(),
    seq.start.ms = integer(),
    seq.stop.ms = integer()
  )
  n.poss.seqs <- tibble(
    seq.num = c(1:nrow(tttbl))
  )
  tttbl <- left_join(tttbl, seq.stats, by = "speaker") %>%
    select(-seq.start.ms, -seq.stop.ms)
  seq.stats <- right_join(select(seq.stats, -speaker), n.poss.seqs,
    by = "seq.num")
  tttbl.edges <- compose_edges(tttbl)
  tttbl.edges$shifted.R.starts <- c(0, tttbl.edges$anchor.R.start.ms[1:(nrow(tttbl.edges)-1)])
  tttbl.edges <- tttbl.edges %>%
    mutate(L.matches.preced.R = ifelse(anchor.L.start.ms == shifted.R.starts, 1, 0))
  sequence <- 0
  for (i in 1:nrow(tttbl)) {
    seq.cont <- tttbl.edges$L.matches.preced.R[i]
    if(!is.na(seq.cont)) {
      if (seq.cont > 0) {
        tttbl.edges$seq.num[i] <- sequence
      } else {
        sequence <- sequence + 1
        tttbl.edges$seq.num[i] <- sequence
      }
    }
  }
  seq.stats <- tttbl.edges %>%
    group_by(seq.num) %>%
    # TO DO add speakers on L and R intseq anchors
    summarize(seq.start.ms = min(anchor.L.start.ms),
      seq.stop.ms = max(anchor.L.start.ms))
  tttbl.edges <- tttbl.edges %>%
    select(-anchor.L.start.ms, -anchor.L.stop.ms, -anchor.L.speaker,
      -anchor.R.start.ms, -anchor.R.stop.ms, -anchor.R.speaker,
      -shifted.R.starts, -L.matches.preced.R) %>%
    left_join(seq.stats, by = "seq.num")
  return(tttbl.edges)
}
