prompt.prev.increment)] &
prompt.spkr == tttbl$response.spkr[i])
# if it doesn't have responses, check for further increments
if (nrow(response.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$prompt.spkr[i],
prompt.prev.increment$start.ms[nrow(prompt.prev.increment)],
prompt.prev.increment$stop.ms[nrow(prompt.prev.increment)],
"left", allowed.gap)
tttbl$prompt.prev.increment.start[i] <-
boundaries$start.ms
tttbl$prompt.prev.increment.stop[i] <-
boundaries$stop.ms
}
}
}
# add post-increments for responses
if (!is.na(tttbl$response.spkr[i])) {
response.post.increment <- int.utts %>%
filter(speaker == tttbl$response.spkr[i] &
start.ms <= tttbl$response.stop.ms[i] + allowed.gap &
stop.ms > tttbl$response.stop.ms[i])
if (nrow(response.post.increment) > 0) {
# check the very first possible candidate for prompts
prompt.check <- tttbl %>%
filter(response.start.ms == response.post.increment$start.ms[1] &
response.spkr == tttbl$response.spkr[i])
# if it doesn't have prompts, check for further increments
if (nrow(prompt.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$response.spkr[i],
response.post.increment$start.ms[1],
response.post.increment$stop.ms[1],
"right", allowed.gap)
tttbl$response.post.increment.start[i] <-
boundaries$start.ms
tttbl$response.post.increment.stop[i] <-
boundaries$stop.ms
}
}
}
i <- 5
# add pre- and post-increments for focus utterances
# exclude potential pre increments that have responses
focus.utt.prev.increment <- tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
if (nrow(focus.utt.prev.increment) > 0) {
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.prev.increment$start.ms[1],
focus.utt.prev.increment$stop.ms[1],
"left", allowed.gap)
tttbl$spkr.prev.increment.start[i] <-
boundaries$start.ms[1]
tttbl$spkr.prev.increment.stop[i] <-
boundaries$stop.ms[1]
}
# exclude potential post increments that have prompts
focus.utt.post.increment <- tttbl %>%
filter(start.ms < tttbl$stop.ms[i] + allowed.gap &
stop.ms > tttbl$stop.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$prompt.spkr))
if (nrow(focus.utt.post.increment) > 0) {
max.idx <- nrow(focus.utt.post.increment)
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.post.increment$start.ms[max.idx],
focus.utt.post.increment$stop.ms[max.idx],
"right", allowed.gap)
tttbl$spkr.post.increment.start[i] <-
boundaries$start.ms
tttbl$spkr.post.increment.stop[i] <-
boundaries$stop.ms
}
# add pre-increments for prompts
if (!is.na(tttbl$prompt.spkr[i])) {
prompt.prev.increment <- int.utts %>%
filter(speaker == tttbl$prompt.spkr[i] &
stop.ms >= tttbl$prompt.start.ms[i] - allowed.gap &
start.ms < tttbl$prompt.start.ms[i])
if (nrow(prompt.prev.increment) > 0) {
# check the very last possible candidate for responses
response.check <- tttbl %>%
filter(prompt.start.ms == prompt.prev.increment$start.ms[nrow(
prompt.prev.increment)] &
prompt.spkr == tttbl$response.spkr[i])
# if it doesn't have responses, check for further increments
if (nrow(response.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$prompt.spkr[i],
prompt.prev.increment$start.ms[nrow(prompt.prev.increment)],
prompt.prev.increment$stop.ms[nrow(prompt.prev.increment)],
"left", allowed.gap)
tttbl$prompt.prev.increment.start[i] <-
boundaries$start.ms
tttbl$prompt.prev.increment.stop[i] <-
boundaries$stop.ms
}
}
}
# add post-increments for responses
if (!is.na(tttbl$response.spkr[i])) {
response.post.increment <- int.utts %>%
filter(speaker == tttbl$response.spkr[i] &
start.ms <= tttbl$response.stop.ms[i] + allowed.gap &
stop.ms > tttbl$response.stop.ms[i])
if (nrow(response.post.increment) > 0) {
# check the very first possible candidate for prompts
prompt.check <- tttbl %>%
filter(response.start.ms == response.post.increment$start.ms[1] &
response.spkr == tttbl$response.spkr[i])
# if it doesn't have prompts, check for further increments
if (nrow(prompt.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$response.spkr[i],
response.post.increment$start.ms[1],
response.post.increment$stop.ms[1],
"right", allowed.gap)
tttbl$response.post.increment.start[i] <-
boundaries$start.ms
tttbl$response.post.increment.stop[i] <-
boundaries$stop.ms
}
}
}
i <- 6
# add pre- and post-increments for focus utterances
# exclude potential pre increments that have responses
focus.utt.prev.increment <- tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
if (nrow(focus.utt.prev.increment) > 0) {
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.prev.increment$start.ms[1],
focus.utt.prev.increment$stop.ms[1],
"left", allowed.gap)
tttbl$spkr.prev.increment.start[i] <-
boundaries$start.ms[1]
tttbl$spkr.prev.increment.stop[i] <-
boundaries$stop.ms[1]
}
# exclude potential post increments that have prompts
focus.utt.post.increment <- tttbl %>%
filter(start.ms < tttbl$stop.ms[i] + allowed.gap &
stop.ms > tttbl$stop.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$prompt.spkr))
if (nrow(focus.utt.post.increment) > 0) {
max.idx <- nrow(focus.utt.post.increment)
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.post.increment$start.ms[max.idx],
focus.utt.post.increment$stop.ms[max.idx],
"right", allowed.gap)
tttbl$spkr.post.increment.start[i] <-
boundaries$start.ms
tttbl$spkr.post.increment.stop[i] <-
boundaries$stop.ms
}
# add pre-increments for prompts
if (!is.na(tttbl$prompt.spkr[i])) {
prompt.prev.increment <- int.utts %>%
filter(speaker == tttbl$prompt.spkr[i] &
stop.ms >= tttbl$prompt.start.ms[i] - allowed.gap &
start.ms < tttbl$prompt.start.ms[i])
if (nrow(prompt.prev.increment) > 0) {
# check the very last possible candidate for responses
response.check <- tttbl %>%
filter(prompt.start.ms == prompt.prev.increment$start.ms[nrow(
prompt.prev.increment)] &
prompt.spkr == tttbl$response.spkr[i])
# if it doesn't have responses, check for further increments
if (nrow(response.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$prompt.spkr[i],
prompt.prev.increment$start.ms[nrow(prompt.prev.increment)],
prompt.prev.increment$stop.ms[nrow(prompt.prev.increment)],
"left", allowed.gap)
tttbl$prompt.prev.increment.start[i] <-
boundaries$start.ms
tttbl$prompt.prev.increment.stop[i] <-
boundaries$stop.ms
}
}
}
# add post-increments for responses
if (!is.na(tttbl$response.spkr[i])) {
response.post.increment <- int.utts %>%
filter(speaker == tttbl$response.spkr[i] &
start.ms <= tttbl$response.stop.ms[i] + allowed.gap &
stop.ms > tttbl$response.stop.ms[i])
if (nrow(response.post.increment) > 0) {
# check the very first possible candidate for prompts
prompt.check <- tttbl %>%
filter(response.start.ms == response.post.increment$start.ms[1] &
response.spkr == tttbl$response.spkr[i])
# if it doesn't have prompts, check for further increments
if (nrow(prompt.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$response.spkr[i],
response.post.increment$start.ms[1],
response.post.increment$stop.ms[1],
"right", allowed.gap)
tttbl$response.post.increment.start[i] <-
boundaries$start.ms
tttbl$response.post.increment.stop[i] <-
boundaries$stop.ms
}
}
}
tttbl <- chi.tttbl
addl.boundaries <- tibble(
speaker = tttbl$speaker[1],
spkr.prev.increment.start = integer(),
spkr.prev.increment.stop = integer(),
spkr.post.increment.start = integer(),
spkr.post.increment.stop = integer(),
prompt.prev.increment.start = integer(),
prompt.prev.increment.stop = integer(),
response.post.increment.start = integer(),
response.post.increment.stop = integer()
)
tttbl <- left_join(tttbl, addl.boundaries, by = "speaker")
for (i in 1:nrow(tttbl)) {
print(i)
# add pre- and post-increments for focus utterances
# exclude potential pre increments that have responses
focus.utt.prev.increment <- tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
if (nrow(focus.utt.prev.increment) > 0) {
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.prev.increment$start.ms[1],
focus.utt.prev.increment$stop.ms[1],
"left", allowed.gap)
tttbl$spkr.prev.increment.start[i] <-
boundaries$start.ms[1]
tttbl$spkr.prev.increment.stop[i] <-
boundaries$stop.ms[1]
}
# exclude potential post increments that have prompts
focus.utt.post.increment <- tttbl %>%
filter(start.ms < tttbl$stop.ms[i] + allowed.gap &
stop.ms > tttbl$stop.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$prompt.spkr))
if (nrow(focus.utt.post.increment) > 0) {
max.idx <- nrow(focus.utt.post.increment)
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.post.increment$start.ms[max.idx],
focus.utt.post.increment$stop.ms[max.idx],
"right", allowed.gap)
tttbl$spkr.post.increment.start[i] <-
boundaries$start.ms
tttbl$spkr.post.increment.stop[i] <-
boundaries$stop.ms
}
# add pre-increments for prompts
if (!is.na(tttbl$prompt.spkr[i])) {
prompt.prev.increment <- int.utts %>%
filter(speaker == tttbl$prompt.spkr[i] &
stop.ms >= tttbl$prompt.start.ms[i] - allowed.gap &
start.ms < tttbl$prompt.start.ms[i])
if (nrow(prompt.prev.increment) > 0) {
# check the very last possible candidate for responses
response.check <- tttbl %>%
filter(prompt.start.ms == prompt.prev.increment$start.ms[nrow(
prompt.prev.increment)] &
prompt.spkr == tttbl$response.spkr[i])
# if it doesn't have responses, check for further increments
if (nrow(response.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$prompt.spkr[i],
prompt.prev.increment$start.ms[nrow(prompt.prev.increment)],
prompt.prev.increment$stop.ms[nrow(prompt.prev.increment)],
"left", allowed.gap)
tttbl$prompt.prev.increment.start[i] <-
boundaries$start.ms
tttbl$prompt.prev.increment.stop[i] <-
boundaries$stop.ms
}
}
}
# add post-increments for responses
if (!is.na(tttbl$response.spkr[i])) {
response.post.increment <- int.utts %>%
filter(speaker == tttbl$response.spkr[i] &
start.ms <= tttbl$response.stop.ms[i] + allowed.gap &
stop.ms > tttbl$response.stop.ms[i])
if (nrow(response.post.increment) > 0) {
# check the very first possible candidate for prompts
prompt.check <- tttbl %>%
filter(response.start.ms == response.post.increment$start.ms[1] &
response.spkr == tttbl$response.spkr[i])
# if it doesn't have prompts, check for further increments
if (nrow(prompt.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$response.spkr[i],
response.post.increment$start.ms[1],
response.post.increment$stop.ms[1],
"right", allowed.gap)
tttbl$response.post.increment.start[i] <-
boundaries$start.ms
tttbl$response.post.increment.stop[i] <-
boundaries$stop.ms
}
}
}
}
if (!("addressee" %in% names(tttbl))) {
tttbl <- tttbl %>%
mutate(addressee = NA)
}
tttbl <- tttbl %>%
select(speaker, annot.clip, start.ms, stop.ms, addressee,
spkr.prev.increment.start, spkr.prev.increment.stop,
spkr.post.increment.start, spkr.post.increment.stop,
prompt.spkr, prompt.start.ms, prompt.stop.ms,
prompt.prev.increment.start, prompt.prev.increment.stop,
response.spkr, response.start.ms, response.stop.ms,
response.post.increment.start, response.post.increment.stop)
nrow(tttbl)
nrow(correct.answers)
tttbl$prompt.prev.increment.start
correct.answers$prompt.prev.increment.start
tttbl$response.post.increment.start
correct.answers$response.post.increment.start
tttbl$spkr.prev.increment.start
correct.answers$spkr.prev.increment.start
tttbl$spkr.post.increment.start
correct.answers$spkr.post.increment.start
i <- 15
focus.utt.prev.increment <- tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
focus.utt.prev.increment
tttbl$start.ms[i]
tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap)
tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i])
tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i])
tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
tttbl[15,]
View(tttbl[15,])
i <- 21
focus.utt.prev.increment <- tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
tttbl$start.ms[i]
focus.utt.prev.increment
focus.utt.post.increment <- tttbl %>%
filter(start.ms < tttbl$stop.ms[i] + allowed.gap &
stop.ms > tttbl$stop.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$prompt.spkr))
focus.utt.post.increment
!is.na(tttbl$prompt.spkr[i])
prompt.prev.increment <- int.utts %>%
filter(speaker == tttbl$prompt.spkr[i] &
stop.ms >= tttbl$prompt.start.ms[i] - allowed.gap &
start.ms < tttbl$prompt.start.ms[i])
prompt.prev.increment
prompt.prev.increment$start.ms[nrow(
prompt.prev.increment)]
tttbl$response.spkr[i]
response.check <- tttbl %>%
filter(prompt.start.ms == prompt.prev.increment$start.ms[nrow(
prompt.prev.increment)] &
prompt.spkr == tttbl$prompt.spkr[i])
response.check
tttbl <- chi.tttbl
addl.boundaries <- tibble(
speaker = tttbl$speaker[1],
spkr.prev.increment.start = integer(),
spkr.prev.increment.stop = integer(),
spkr.post.increment.start = integer(),
spkr.post.increment.stop = integer(),
prompt.prev.increment.start = integer(),
prompt.prev.increment.stop = integer(),
response.post.increment.start = integer(),
response.post.increment.stop = integer()
)
tttbl <- left_join(tttbl, addl.boundaries, by = "speaker")
for (i in 1:nrow(tttbl)) {
# add pre- and post-increments for focus utterances
# exclude potential pre increments that have responses
focus.utt.prev.increment <- tttbl %>%
filter(stop.ms >= tttbl$start.ms[i] - allowed.gap &
start.ms < tttbl$start.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$response.spkr))
if (nrow(focus.utt.prev.increment) > 0) {
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.prev.increment$start.ms[1],
focus.utt.prev.increment$stop.ms[1],
"left", allowed.gap)
tttbl$spkr.prev.increment.start[i] <-
boundaries$start.ms[1]
tttbl$spkr.prev.increment.stop[i] <-
boundaries$stop.ms[1]
}
# exclude potential post increments that have prompts
focus.utt.post.increment <- tttbl %>%
filter(start.ms < tttbl$stop.ms[i] + allowed.gap &
stop.ms > tttbl$stop.ms[i] &
speaker == tttbl$speaker[i] &
is.na(tttbl$prompt.spkr))
if (nrow(focus.utt.post.increment) > 0) {
max.idx <- nrow(focus.utt.post.increment)
boundaries <- find_TCU_edge_focal(tttbl, tttbl$speaker[i],
focus.utt.post.increment$start.ms[max.idx],
focus.utt.post.increment$stop.ms[max.idx],
"right", allowed.gap)
tttbl$spkr.post.increment.start[i] <-
boundaries$start.ms
tttbl$spkr.post.increment.stop[i] <-
boundaries$stop.ms
}
# add pre-increments for prompts
if (!is.na(tttbl$prompt.spkr[i])) {
prompt.prev.increment <- int.utts %>%
filter(speaker == tttbl$prompt.spkr[i] &
stop.ms >= tttbl$prompt.start.ms[i] - allowed.gap &
start.ms < tttbl$prompt.start.ms[i])
if (nrow(prompt.prev.increment) > 0) {
# check the very last possible candidate for responses
response.check <- tttbl %>%
filter(prompt.start.ms == prompt.prev.increment$start.ms[nrow(
prompt.prev.increment)] &
prompt.spkr == tttbl$prompt.spkr[i])
# if it doesn't have responses, check for further increments
if (nrow(response.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$prompt.spkr[i],
prompt.prev.increment$start.ms[nrow(prompt.prev.increment)],
prompt.prev.increment$stop.ms[nrow(prompt.prev.increment)],
"left", allowed.gap)
tttbl$prompt.prev.increment.start[i] <-
boundaries$start.ms
tttbl$prompt.prev.increment.stop[i] <-
boundaries$stop.ms
}
}
}
# add post-increments for responses
if (!is.na(tttbl$response.spkr[i])) {
response.post.increment <- int.utts %>%
filter(speaker == tttbl$response.spkr[i] &
start.ms <= tttbl$response.stop.ms[i] + allowed.gap &
stop.ms > tttbl$response.stop.ms[i])
if (nrow(response.post.increment) > 0) {
# check the very first possible candidate for prompts
prompt.check <- tttbl %>%
filter(response.start.ms == response.post.increment$start.ms[1] &
response.spkr == tttbl$response.spkr[i])
# if it doesn't have prompts, check for further increments
if (nrow(prompt.check) == 0) {
boundaries <- find_TCU_edge_nonfocal(
tttbl, tttbl$speaker[i], int.utts, tttbl$response.spkr[i],
response.post.increment$start.ms[1],
response.post.increment$stop.ms[1],
"right", allowed.gap)
tttbl$response.post.increment.start[i] <-
boundaries$start.ms
tttbl$response.post.increment.stop[i] <-
boundaries$stop.ms
}
}
}
}
if (!("addressee" %in% names(tttbl))) {
tttbl <- tttbl %>%
mutate(addressee = NA)
}
tttbl <- tttbl %>%
select(speaker, annot.clip, start.ms, stop.ms, addressee,
spkr.prev.increment.start, spkr.prev.increment.stop,
spkr.post.increment.start, spkr.post.increment.stop,
prompt.spkr, prompt.start.ms, prompt.stop.ms,
prompt.prev.increment.start, prompt.prev.increment.stop,
response.spkr, response.start.ms, response.stop.ms,
response.post.increment.start, response.post.increment.stop)
tttbl$spkr.prev.increment.start
correct.answers$spkr.prev.increment.start
tttbl$spkr.post.increment.start
correct.answers$spkr.post.increment.start
tttbl$prompt.prev.increment.start
correct.answers$prompt.prev.increment.start
tttbl$response.post.increment.start
correct.answers$response.post.increment.start
correct.answers <- read_csv("testdata1.stretch-correct.csv")
tttbl$spkr.prev.increment.start
correct.answers$spkr.prev.increment.start
rm(list = ls())
