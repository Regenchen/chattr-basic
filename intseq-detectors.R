compose_edges <- function(tttbl.seq) {
  tttbl.seq <- tttbl.seq %>%
    mutate(
      anchor.L.start.ms = NA,
      anchor.L.stop.ms = NA,
      anchor.L.speaker = NA,
      anchor.R.start.ms = NA,
      anchor.R.stop.ms = NA,
      anchor.R.speaker = NA
    )
  for (i in 1:nrow(tttbl.seq)) {
    # find the earliest increment
    prompt.start <- tttbl.seq$prompt.start.ms[i]
    # if there's a prompt...
    if (!is.na(prompt.start)) {
      tttbl.seq$anchor.L.speaker[i] <- tttbl.seq$prompt.spkr[i]
      prompt.prev.start <- tttbl.seq$prompt.prev.increment.start[i]
      # look for a pre-prompt utterance
      # if it's there, take that as the earliest
      if(!is.na(prompt.prev.start)) {
        tttbl.seq$anchor.L.start.ms[i] <- prompt.prev.start
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$prompt.prev.increment.stop[i]
      } else { # if not, set the prompt start as the earliest
        tttbl.seq$anchor.L.start.ms[i] <- prompt.start
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$prompt.stop.ms[i]
      }
    } else { # if there's no prompt, set the focus spkr
      # start as the earliest
      tttbl.seq$anchor.L.speaker[i] <- tttbl.seq$speaker[i]
      if (!is.na(tttbl.seq$spkr.prev.increment.start[i])) {
        tttbl.seq$anchor.L.start.ms[i] <- tttbl.seq$spkr.prev.increment.start[i]
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$spkr.prev.increment.stop[i]
      } else {
        tttbl.seq$anchor.L.start.ms[i] <- tttbl.seq$start.ms[i]
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$stop.ms[i]
      }
    }
    # find the latest increment
    response.stop <- tttbl.seq$response.stop.ms[i]
    # if there's a response...
    if (!is.na(response.stop)) {
      tttbl.seq$anchor.R.speaker[i] <- tttbl.seq$response.spkr[i]
      response.post.stop <- tttbl.seq$response.post.increment.stop[i]
      # look for a post-response utterance
      # if it's there, take that as the latest
      if (!is.na(response.post.stop)) {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$response.post.increment.start[i]
        tttbl.seq$anchor.R.stop.ms[i] <- response.post.stop
      } else { # if not, set the response stop as the latest
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$response.start.ms[i]
        tttbl.seq$anchor.R.stop.ms[i] <- response.stop
      }
    } else { # if there's no response, set the focus spkr
      # stop as the latest
      tttbl.seq$anchor.R.speaker[i] <- tttbl.seq$speaker[i]
      if (!is.na(tttbl.seq$spkr.post.increment.start[i])) {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$spkr.post.increment.start[i]
        tttbl.seq$anchor.R.stop.ms[i] <- tttbl.seq$spkr.post.increment.stop[i]
      } else {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$start.ms[i]
        tttbl.seq$anchor.R.stop.ms[i] <- tttbl.seq$stop.ms[i]
      }
    }
  }
  return(tttbl.seq)
}

# Finds continuous sequences of interaction featuring the focus child
# and their contingently prompting/responding interactants
# uses the turn transition table format generated by fetch_transitions()
fetch_intseqs <- function(tttbl) {
  seq.stats <- tibble(
    speaker = character(),
    seq.num = integer(),
    seq.start.ms = integer(),
    seq.stop.ms = integer()
  )
  n.poss.seqs <- tibble(
    seq.num = c(1:nrow(tttbl))
  )
  tttbl.seq <- left_join(tttbl, seq.stats, by = "speaker") %>%
    select(-seq.start.ms, -seq.stop.ms)
  seq.stats <- right_join(select(seq.stats, -speaker), n.poss.seqs,
    by = "seq.num")
  # find the edge utterance associated with each focal speaker vocalization
  tttbl.edges <- compose_edges(tttbl.seq)
  # check whether the right edge turn of each focal speaker vocalization
  # (except the final one) is involved in the next focal speaker vocalization
  tttbl.edges <- tttbl.edges %>%
    mutate(
      R.edge.start = paste0(anchor.R.speaker, anchor.R.start.ms),
      L.edge.start = paste0(anchor.L.speaker, anchor.L.start.ms),
      involved.turns = paste0(
        paste0(speaker, spkr.prev.increment.start), "-",
        paste0(speaker, start.ms), "-",
        paste0(speaker, spkr.post.increment.start), "-",
        paste0(prompt.spkr, prompt.prev.increment.start), "-",
        paste0(prompt.spkr, prompt.start.ms), "-",
        paste0(response.spkr, response.start.ms), "-",
        paste0(response.spkr, response.post.increment.start)),
      R.edge.in.next.tt = 0,
      seq.num = 0
    )
  for (i in 1:(nrow(tttbl.edges)-1)) {
    curr.R.edge <- tttbl.edges$R.edge.start[i]
    tttbl.edges$R.edge.in.next.tt[i] <-
      ifelse(!is.na(curr.R.edge) &
          # check if right edge is actually involved in the next vocalization
          grepl(curr.R.edge, tttbl.edges$involved.turns[i+1])|
          # treat right-hanging vocalizations that overlap with the left
          # edge of the next vocalization as having edge overlap
          tttbl.edges$anchor.R.stop.ms[i] >=
          tttbl.edges$anchor.L.start.ms[i+1],
        1, 0)
  }
  # detect touching edge vocalizations separated by orphan focal
  # speaker vocalizations or periods less than the allowed gap duration
  #
  # GO HERE SECOND -- we aren't catching sequences bounded by different
  # non-focal speaker utterances, e.g., CHN-FAN | MAN-CHN-FAN but we should
  #
  for (i in 1:(nrow(tttbl.edges)-1)) {
    curr.R.edge <- tttbl.edges$R.edge.start[i]
    common.L.edge <- which(tttbl.edges$L.edge.start == curr.R.edge)
    # ensure that these related downstream vocalizations are grouped with
    # the prior vocalization sequence and are not falsely marked as a new start
    if (length(common.L.edge) > 0) {
      # get rid of self-matches for focal-speaker only chunks (dealt with later)
      common.L.edge <- common.L.edge[!(i %in% common.L.edge)]
      if (length(common.L.edge) > 0) {
        tttbl.edges$R.edge.in.next.tt[i:(max(common.L.edge)-1)] <- 1
      }
    }
  }
  # group together transitions with matching/overlapping edges;
  # an utterance with no match/overlap on its right edge begins a new int seq
  sequence <- 0
  prev.state <- 0
  for (i in 1:nrow(tttbl.edges)) {
    curr.state <- tttbl.edges$R.edge.in.next.tt[i]
    if (prev.state == 1) {
      tttbl.edges$seq.num[i] <- sequence
    } else if (prev.state == 0 & curr.state == 1) {
      sequence <- sequence + 1
      tttbl.edges$seq.num[i] <- sequence
    } else if (prev.state == 0 &
        (!is.na(tttbl.edges$prompt.spkr[i])|
            !is.na(tttbl.edges$response.spkr[i])) &
        #
        # START HERE -- this is only eliminating single-increment
        # focal speaker utterances!
        #
        # don't count focal-speaker-only utterance seqs
        # findable here as the same L and R anchor start times
        tttbl.edges$anchor.L.start.ms[i] !=
        tttbl.edges$anchor.R.start.ms[i]) {
      sequence <- sequence + 1
      tttbl.edges$seq.num[i] <- sequence
    }
    prev.state <- tttbl.edges$R.edge.in.next.tt[i]
  }
  # find the earliest and latest turn info associated with each int seq
  uniq.L.anchors <- tttbl.edges %>%
    arrange(anchor.L.start.ms) %>%
    group_by(seq.num) %>%
    mutate(id = row_number()) %>%
    filter(seq.num > 0 & id == 1) %>%
    select(seq.num, anchor.L.start.ms, anchor.L.speaker) %>%
    rename(seq.start.ms = anchor.L.start.ms)
  uniq.R.anchors <- tttbl.edges %>%
    arrange(seq.num, -anchor.R.stop.ms) %>%
    group_by(seq.num) %>%
    mutate(id = row_number()) %>%
    filter(seq.num > 0 & id == 1) %>%
    arrange(start.ms) %>%
    select(seq.num, anchor.R.stop.ms, anchor.R.speaker) %>%
    rename(seq.stop.ms = anchor.R.stop.ms)
  seq.stats <- tttbl.edges %>%
    group_by(seq.num) %>%
    filter(seq.num > 0) %>%
    summarize(seq.start.ms = min(anchor.L.start.ms),
      seq.stop.ms = max(anchor.R.stop.ms)) %>%
    left_join(uniq.L.anchors, by = c("seq.num", "seq.start.ms")) %>%
    left_join(uniq.R.anchors, by = c("seq.num", "seq.stop.ms")) %>%
    rename(seq.start.spkr = anchor.L.speaker,
           seq.stop.spkr = anchor.R.speaker) %>%
    distinct()
  # remove onset, offset, and speaker info for focal-speaker-only sequences
  focal.spch.only <- which(seq.stats$seq.num == 0)
  seq.stats$seq.start.ms[focal.spch.only] <- NA
  seq.stats$seq.stop.ms[focal.spch.only] <- NA
  seq.stats$seq.start.spkr[focal.spch.only] <- NA
  seq.stats$seq.stop.spkr[focal.spch.only] <- NA
  intseqtbl <- tttbl.edges %>%
    select(-anchor.L.start.ms, -anchor.L.stop.ms, -anchor.L.speaker,
      -anchor.R.start.ms, -anchor.R.stop.ms, -anchor.R.speaker,
      -R.edge.start, -L.edge.start, -involved.turns, -R.edge.in.next.tt) %>%
    left_join(seq.stats, by = "seq.num")
  intseqtbl$seq.num[which(intseqtbl$seq.num == 0)] <- NA
  return(intseqtbl)
}
