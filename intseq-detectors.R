compose_edges <- function(tttbl.seq) {
  tttbl.seq <- tttbl.seq %>%
    mutate(
      anchor.L.start.ms = NA,
      anchor.L.stop.ms = NA,
      anchor.L.speaker = NA,
      anchor.R.start.ms = NA,
      anchor.R.stop.ms = NA,
      anchor.R.speaker = NA
    )
  for (i in 1:nrow(tttbl.seq)) {
    # find the earliest increment
    prompt.start <- tttbl.seq$prompt.start.ms[i]
    # if there's a prompt...
    if (!is.na(prompt.start)) {
      tttbl.seq$anchor.L.speaker[i] <- tttbl.seq$prompt.spkr[i]
      prompt.prev.start <- tttbl.seq$prompt.prev.increment.start[i]
      # look for a pre-prompt utterance
      # if it's there, take that as the earliest
      if(!is.na(prompt.prev.start)) {
        tttbl.seq$anchor.L.start.ms[i] <- prompt.prev.start
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$prompt.prev.increment.stop[i]
      } else { # if not, set the prompt start as the earliest
        tttbl.seq$anchor.L.start.ms[i] <- prompt.start
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$prompt.stop.ms[i]
      }
    } else { # if there's no prompt, set the focus spkr
      # start as the earliest
      tttbl.seq$anchor.L.speaker[i] <- tttbl.seq$speaker[i]
      if (!is.na(tttbl.seq$spkr.prev.increment.start[i])) {
        tttbl.seq$anchor.L.start.ms[i] <- tttbl.seq$spkr.prev.increment.start[i]
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$spkr.prev.increment.stop[i]
      } else {
        tttbl.seq$anchor.L.start.ms[i] <- tttbl.seq$start.ms[i]
        tttbl.seq$anchor.L.stop.ms[i] <- tttbl.seq$stop.ms[i]
      }
    }
    # find the latest increment
    response.stop <- tttbl.seq$response.stop.ms[i]
    # if there's a response...
    if (!is.na(response.stop)) {
      tttbl.seq$anchor.R.speaker[i] <- tttbl.seq$response.spkr[i]
      response.post.stop <- tttbl.seq$response.post.increment.stop[i]
      # look for a post-response utterance
      # if it's there, take that as the latest
      if (!is.na(response.post.stop)) {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$response.post.increment.start[i]
        tttbl.seq$anchor.R.stop.ms[i] <- response.post.stop
      } else { # if not, set the response stop as the latest
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$response.start.ms[i]
        tttbl.seq$anchor.R.stop.ms[i] <- response.stop
      }
    } else { # if there's no response, set the focus spkr
      # stop as the latest
      tttbl.seq$anchor.R.speaker[i] <- tttbl.seq$speaker[i]
      if (!is.na(tttbl.seq$spkr.post.increment.start[i])) {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$spkr.post.increment.start[i]
        tttbl.seq$anchor.R.stop.ms[i] <- tttbl.seq$spkr.post.increment.stop[i]
      } else {
        tttbl.seq$anchor.R.start.ms[i] <- tttbl.seq$start.ms[i]
        tttbl.seq$anchor.R.stop.ms[i] <- tttbl.seq$stop.ms[i]
      }
    }
  }
  return(tttbl.seq)
}

# Finds continuous sequences of interaction featuring the focus child
# and their contingently prompting/responding interactants
# uses the turn transition table format generated by fetch_transitions()
fetch_intseqs <- function(tttbl, allowed.gap) {
  seq.stats <- tibble(
    speaker = character(),
    intseq.num = integer(),
    seq.start.ms = integer(),
    seq.stop.ms = integer()
  )
  n.poss.seqs <- tibble(
    intseq.num = c(1:nrow(tttbl))
  )
  tttbl.seq <- left_join(tttbl, seq.stats, by = "speaker") %>%
    select(-seq.start.ms, -seq.stop.ms)
  seq.stats <- right_join(select(seq.stats, -speaker), n.poss.seqs,
    by = "intseq.num")
  # find the edge utterance associated with each focal speaker vocalization
  tttbl.edges <- compose_edges(tttbl.seq)
  # group utterances into sequences by touching/overlapping/near edges
  tttbl.edges$prior.R.edge.stop <- c(0,
    tttbl.edges$anchor.R.stop.ms[1:(nrow(tttbl.edges)-1)])
  tttbl.edges <- tttbl.edges %>%
    mutate(
      ms.lapsed.prior.edge = anchor.L.start.ms - prior.R.edge.stop,
      # "close" here includes any edges closer than the allowed gap,
      # including overlapping ones
      close.to.prev.edge = ifelse(ms.lapsed.prior.edge <= allowed.gap, 1, 0),
      new.seq = case_when(
        close.to.prev.edge == 0 & (!is.na(prompt.spkr)|!is.na(response.spkr)) ~ 1,
        close.to.prev.edge == 0 & is.na(prompt.spkr) & is.na(response.spkr) ~ 999,
        TRUE ~ 0),
      focal.seq = new.seq)
  # separate interactive sequences from focal-speaker-only sequences
  for (i in 2:nrow(tttbl.edges)) {
    tttbl.edges$focal.seq[i] <- case_when(
      tttbl.edges$focal.seq[i] == 1 ~ 1,
      tttbl.edges$focal.seq[i] == 999 ~ 999,
      tttbl.edges$focal.seq[i] == 0 &
        tttbl.edges$focal.seq[i-1] > 800 ~ 888,
      TRUE ~ 0)
  }
  # check for continuations separated by focal-speaker-only
  # sequences
  tttbl.edges$ms.lapsed.prior.edge.prev <- c(0,
    tttbl.edges$ms.lapsed.prior.edge[1:(nrow(tttbl.edges)-1)])
  check.continuation.idx <- which(
    tttbl.edges$close.to.prev.edge == 0 &
      tttbl.edges$new.seq == 1 &
      tttbl.edges$focal.seq == 1 &
      tttbl.edges$ms.lapsed.prior.edge.prev <= 0)
  for (i in check.continuation.idx) {
    if (i > 1) {
      prev.zero <- max(which(tttbl.edges$close.to.prev.edge[1:(i-1)] == 0))
      verified.new <- ifelse(
        tttbl.edges$anchor.L.start.ms[i] -
          tttbl.edges$anchor.R.stop.ms[prev.zero] <= allowed.gap,
        0, tttbl.edges$new.seq[i])
      tttbl.edges$new.seq[i] <- verified.new
      tttbl.edges$focal.seq[i] <- verified.new
    }
  }
  # reassign values for sequence starts/continuations
  tttbl.edges$focal.seq[which(tttbl.edges$focal.seq < 888)] <- NA
  tttbl.edges$focal.seq[which(tttbl.edges$focal.seq == 888)] <- 0
  tttbl.edges$focal.seq[which(tttbl.edges$focal.seq == 999)] <- 1
  tttbl.edges$new.seq[which(!is.na(tttbl.edges$focal.seq))] <- NA
  # number the sequences
  tttbl.edges$intseq.num <- cumsum(ifelse(is.na(tttbl.edges$new.seq),
    0, tttbl.edges$new.seq)) + tttbl.edges$new.seq*0
  tttbl.edges$focalonlyseq.num <- cumsum(ifelse(is.na(tttbl.edges$focal.seq),
    0, tttbl.edges$focal.seq)) + tttbl.edges$focal.seq*0
  # find the earliest and latest turn info (start/stop/speaker)
  # associated with each intseq and focal-only seq
  # intseqs
  uniq.L.anchors.intseq <- tttbl.edges %>%
    arrange(anchor.L.start.ms) %>%
    group_by(intseq.num) %>%
    mutate(id = row_number()) %>%
    filter(intseq.num > 0 & id == 1) %>%
    select(intseq.num, anchor.L.start.ms, anchor.L.speaker) %>%
    rename(seq.start.ms = anchor.L.start.ms)
  uniq.R.anchors.intseq <- tttbl.edges %>%
    arrange(intseq.num, -anchor.R.stop.ms) %>%
    group_by(intseq.num) %>%
    mutate(id = row_number()) %>%
    filter(intseq.num > 0 & id == 1) %>%
    arrange(start.ms) %>%
    select(intseq.num, anchor.R.stop.ms, anchor.R.speaker) %>%
    rename(seq.stop.ms = anchor.R.stop.ms)
  seq.stats.intseq <- tttbl.edges %>%
    group_by(intseq.num) %>%
    filter(intseq.num > 0) %>%
    summarize(seq.start.ms = min(anchor.L.start.ms),
      seq.stop.ms = max(anchor.R.stop.ms)) %>%
    left_join(uniq.L.anchors.intseq, by = c("intseq.num", "seq.start.ms")) %>%
    left_join(uniq.R.anchors.intseq, by = c("intseq.num", "seq.stop.ms")) %>%
    rename(
      intseq.start.ms = seq.start.ms,
      intseq.stop.ms = seq.stop.ms,
      intseq.start.spkr = anchor.L.speaker,
      intseq.stop.spkr = anchor.R.speaker) %>%
    distinct() %>%
    select(intseq.num, intseq.start.spkr, intseq.start.ms,
      intseq.stop.spkr, intseq.stop.ms)
  # focal-only seqs
  uniq.L.anchors.foconlyseq <- tttbl.edges %>%
    arrange(anchor.L.start.ms) %>%
    group_by(focalonlyseq.num) %>%
    mutate(id = row_number()) %>%
    filter(focalonlyseq.num > 0 & id == 1) %>%
    select(focalonlyseq.num, anchor.L.start.ms, anchor.L.speaker) %>%
    rename(seq.start.ms = anchor.L.start.ms)
  uniq.R.anchors.foconlyseq <- tttbl.edges %>%
    arrange(focalonlyseq.num, -anchor.R.stop.ms) %>%
    group_by(focalonlyseq.num) %>%
    mutate(id = row_number()) %>%
    filter(focalonlyseq.num > 0 & id == 1) %>%
    arrange(start.ms) %>%
    select(focalonlyseq.num, anchor.R.stop.ms, anchor.R.speaker) %>%
    rename(seq.stop.ms = anchor.R.stop.ms)
  seq.stats.foconlyseq <- tttbl.edges %>%
    group_by(focalonlyseq.num) %>%
    filter(focalonlyseq.num > 0) %>%
    summarize(seq.start.ms = min(anchor.L.start.ms),
      seq.stop.ms = max(anchor.R.stop.ms)) %>%
    left_join(uniq.L.anchors.foconlyseq, by = c("focalonlyseq.num", "seq.start.ms")) %>%
    left_join(uniq.R.anchors.foconlyseq, by = c("focalonlyseq.num", "seq.stop.ms")) %>%
    rename(
      focalonlyseq.start.ms = seq.start.ms,
      focalonlyintseq.stop.ms = seq.stop.ms,
      focalonlyintseq.start.spkr = anchor.L.speaker,
      focalonlyintseq.stop.spkr = anchor.R.speaker) %>%
    distinct() %>%
    select(focalonlyseq.num, focalonlyintseq.start.spkr, focalonlyseq.start.ms,
      focalonlyintseq.stop.spkr, focalonlyintseq.stop.ms)
  # remove onset, offset, and speaker info for focal-speaker-only sequences
  intseqtbl <- tttbl.edges %>%
    select(
      -anchor.L.start.ms, -anchor.L.stop.ms, -anchor.L.speaker,
      -anchor.R.start.ms, -anchor.R.stop.ms, -anchor.R.speaker,
      -prior.R.edge.stop, -ms.lapsed.prior.edge, -close.to.prev.edge,
      -new.seq, -focal.seq) %>%
    left_join(seq.stats.intseq, by = "intseq.num") %>%
    left_join(seq.stats.foconlyseq, by = "focalonlyseq.num")
  return(intseqtbl)
}
